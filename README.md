# cat-regex
CatRegex is a tiny library of Regex builder combinators written in pure Haskell. You can use it to build PCRE-compliant Regex strings in a simple, readable way with pure Haskell code.

It's heavily inspired by the [magic-regexp](https://regexp.dev/) library for Javascript/Typescript.

This library builds an abstract syntax tree behind the scenes and then efficiently turns it into a PCRE-compliant Regex string. It's lazy by default.

The `stringify` function is polymorphic in its return type, and you can cast it to any of Haskell's string types. It uses the IsString typeclass, the same typeclass used by the OverloadedStrings language extension.

The documentation for this library is **still in progress**. Still, I'll give a few examples:

1. Regex for extracting the contents from an HTML \<img\> tag:

```haskell
imageTagSrc :: String
imageTagSrc = stringify $
    char '<'
    <.+> anyAmountOf whitespace
    <.+> exactly "img"
    <.+> capture (anyAmountOf anyChar)
    <.+> char '>'
    -- Output: <\s*img(.*)>
```

As you can see in the example above, the <.+> operator combines tokens generated by each function used in that little thread. It's right-associative. The `<.+>` operator does a little more more behind the scenes than simply store tokens. If you want to use a normal Haskell list to hold your tokens, however, you can! Just use the `regexFromList` function.

All the `regexFromList` function really does is apply the `<.+>` operator to each item in the list with a foldr. The output will, thus, always be the same.

```haskell
imageTagSrc' :: String
imageTagSrc' = stringify $ regexFromList
    [ char '<'
    , anyAmountOf whitespace
    , exactly "img"
    , capture (anyAmountOf anyChar)
    , char '>' ]
    -- Output: <\s*img(.*)>
```

2. Regex for extracting the contents of any HTML tag, as well as whether or not it's a closing tag:

```haskell
htmlTag' :: String
htmlTag' = stringify $
    char '<'
    <.+> capture (optionally $ char '/')
    <.+> capture (oneOrMore anyChar)
    <.+> char '>'
    -- Output: <(\/?)(.+)>
```
The capture groups will hold the information about the tag.

As a side note: The strings passed to the `char` and `exactly` functions get **proper escape sequences added behind the scenes**, so don't worry about escaping characters like `.` and `/`. That's why I've not had to escape the '/' in my example.

If you wish to ensure your strings never get any escape sequences added behind the scenes, use the `char'` and `exactly'` function variations instead. Beware you can break the resulting Regex string if you do this, however. The duty of adding the necessary escape sequences will be yours.


3. Regex for validating a hex color code (like \#ffffff) and extracting its value:

```haskell
-- Valid hexadecimal digits.
hexDigits :: RegexToken
hexDigits = digit .||+ inRange 'a' 'f' .||+ inRange 'A' 'F'

-- Regex string using the helper above.
hexColor :: String
hexColor = stringify $
    startOfLine
    <.+> optionally (char '#')
    <.+> capture (
        amountOf 6 hexDigits
        .||+ amountOf 3 hexDigits
    )
    <.+> endOfLine
    -- Output: ^#?((?:(?:\d|(?:[a-f]|[A-F])){6}|(?:\d|(?:[a-f]|[A-F])){3}))$
```

Defining your own helper functions to avoid repetition is very helpful, as shown above.

As you can see, the output regex string can get very messy when alternative branches are used (through the `.||+` operator) due to the excess of non-capturing groups used to ensure correctness.

We can improve that a little by using the more efficient function `inRanges` and giving up some readability:

```haskell
hexDigits' :: RegexToken
hexDigits' = inRanges [('a', 'f'), ('A', 'F'), ('0', '9')]

hexColor' :: String
hexColor' = stringify $
    startOfLine
    <.+> optionally (char '#')
    <.+> capture (
        amountOf 6 hexDigits'
        .||+ amountOf 3 hexDigits'
    )
    <.+> endOfLine
    -- Output: ^#?((?:[a-fA-F0-9]{6}|[a-fA-F0-9]{3}))$
```

A lot cleaner! Still has an unnecessary non-capture group, but that's a very minimal issue.


## To Do:
1. Add documentation for every function.
2. Add better examples to the README.
