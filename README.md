# cat-regex
CatRegex is a tiny library of Regex builder combinators written in pure Haskell. You can use it to build PCRE-compliant Regex strings in a simple, readable way with pure Haskell code.

It's heavily inspired by the [magic-regexp](https://regexp.dev/) library for Javascript/Typescript.

This library builds an abstract syntax tree behind the scenes and then efficiently turns it into a PCRE-compliant Regex string. It's lazy by default.

The `stringify` function is polymorphic in its return type, and you can cast it to any of Haskell's string types. It uses the IsString typeclass, the same typeclass used by the OverloadedStrings language extension.

A few examples:

1. Regex for extracting the src string from an HTML \<img\> tag:

```haskell
imageTagSrc :: String
imageTagSrc = stringify $
    char '<'
    <.+> anyAmountOf whitespace
    <.+> exactly "img"
    <.+> oneOrMore (notOneOf ['>'])
    <.+> exactly "src"
    <.+> anyAmountOf whitespace
    <.+> oneOf [ '"', '\'' ]
    <.+> capture (anyAmountOf anyChar)
    <.+> oneOf [ '"', '\'' ]
    <.+> anyAmountOf (notOneOf ['>'])
    <.+> char '>'

    -- Output: <\s*img[^>]+src\s*["'](.*)["'][^>]*>
```

As you can see in the example above, the <.+> operator combines tokens generated by each function used in that little thread. It's right-associative.

The `<.+>` operator does a little more more behind the scenes than simply store tokens. If you want to use a normal Haskell list to hold your tokens, however, you can! Just use the `regexFromList` function.

All the `regexFromList` function really does is apply the `<.+>` operator to each item in the list with a foldr. The output will, thus, always be the same.

```haskell
imageTagSrc' :: String
imageTagSrc' = stringify $ regexFromList
    [ char '<'
    , exactly "img"
    , oneOrMore (notOneOf ['>'])
    , exactly "src"
    , anyAmountOf whitespace
    , oneOf [ '"', '\'' ]
    , capture (anyAmountOf anyChar)
    , oneOf [ '"', '\'' ]
    , anyAmountOf (notOneOf ['>'])
    , char '>' ]

-- Output: <\s*img[^>]+src\s*["'](.*)["'][^>]*>
```

2. Regex for extracting the contents of any HTML tag, as well as whether it's a closing tag:

```haskell
htmlTag' :: String
htmlTag' = stringify $
    char '<'
    <.+> capture (optionally $ char '/')
    <.+> capture (oneOrMore anyChar)
    <.+> char '>'

    -- Output: <(\/?)(.+)>
```

3. Regex for validating a hex color code and extracting its value:

```haskell
-- Valid hexadecimal digits.
hexDigits :: RegexToken
hexDigits = digit .||+ inRange 'a' 'f' .||+ inRange 'A' 'F'

-- Regex string using the helper above.
hexColor :: String
hexColor = stringify $
    startOfLine
    <.+> optionally (char '#')
    <.+> capture (
        amountOf 6 hexDigits
        .||+ amountOf 3 hexDigits
    )
    <.+> endOfLine

-- Output: ^#?((?:(?:\d|(?:[a-f]|[A-F])){6}|(?:\d|(?:[a-f]|[A-F])){3}))$
```

Defining your own helper functions to avoid repetition is very helpful, as shown above.

As you can see, the output regex string can get very messy when alternative branches are used (through the `.||+` operator) due to the excess of non-capturing groups used to ensure correctness.

We can improve that a little by using the more efficient function `inRanges` and giving up some readability:

```haskell
hexDigits' :: RegexToken
hexDigits' = inRanges [('a', 'f'), ('A', 'F'), ('0', '9')]

hexColor' :: String
hexColor' = stringify $
    startOfLine
    <.+> optionally (char '#')
    <.+> capture (
        amountOf 6 hexDigits'
        .||+ amountOf 3 hexDigits'
    )
    <.+> endOfLine

-- Output: ^#?((?:[a-fA-F0-9]{6}|[a-fA-F0-9]{3}))$
```

A lot cleaner! Still has an unnecessary non-capture group, but that's a very minimal issue.
